diff --git a/app.py b/app.py
index db3f63ba8..102256834 100755
--- a/app.py
+++ b/app.py
@@ -151,6 +151,7 @@ class App:
                 logging.info(f"LOAD RACK: Skipping player {player} - game not started")
 
     async def accept_new_letter(self, next_letter: str, position: int, now_ms: int) -> None:
+        print(f"accept_new_letter {next_letter}, {position}")
         if self._player_count > 1:
             # Replace the tile in the rack that was hit, then replace that same tile in the other rack.
             hit_rack, other_rack, position_offset = (0, 1, 3) if position < 3 else (1, 0, -3)
@@ -166,8 +167,9 @@ class App:
         self._update_player_to_cube_set_mapping()
         for player in range(self._player_count):
             cube_set_id = self._player_to_cube_set.get(player)
-            if cube_set_id is not None:
-                await cubes_to_game.accept_new_letter(self._publish_queue, next_letter, changed_tile.id, cube_set_id, now_ms)
+            print(f"accepting new letter id {changed_tile.id}")
+            await cubes_to_game.accept_new_letter(self._publish_queue, next_letter,
+                                                  changed_tile.id, cube_set_id, now_ms)
 
         self._update_previous_guesses()
         self._update_remaining_previous_guesses()
@@ -178,18 +180,19 @@ class App:
             for player in range(self._player_count):
                 await self.guess_tiles(self._last_guess, False, player, now_ms)
 
-    async def letter_lock(self, position: int | None, now_ms: int) -> bool:
-        lock_change = False
-        # Update player-to-cube-set mapping before sending locks
-        self._update_player_to_cube_set_mapping()
+    async def letter_lock(self, position: int, locked: bool, now_ms: int) -> bool:
+        position_offset = 0
+        if self._player_count > 1:
+            hit_rack, position_offset = (0, 3) if position < 3 else (1, -3)
+
+        locked_tile_id = self._player_racks[hit_rack].position_to_id(position + position_offset)
+
+        lock_changed = False
         for player in range(self._player_count):
-            cube_set_id = self._player_to_cube_set.get(player)
-            if cube_set_id is not None:
-                lock_change |= await cubes_to_game.letter_lock(self._publish_queue,
-                    cube_set_id,
-                    self._player_racks[player].position_to_id(position) if position else None,
-                    now_ms)
-        return lock_change
+            print(f"locking position {position}, id {locked_tile_id}")
+            lock_changed |= await cubes_to_game.letter_lock(self._publish_queue, player,
+                                            locked_tile_id if locked else None, now_ms)
+        return lock_changed
 
     def add_guess(self, guess: str, player: int) -> None:
         self._score_card.add_guess(guess, player)
diff --git a/pygamegameasync.py b/pygamegameasync.py
index ec8428cba..c023dccf4 100755
--- a/pygamegameasync.py
+++ b/pygamegameasync.py
@@ -530,9 +530,6 @@ class RemainingPreviousGuessesDisplay(PreviousGuessesDisplayBase):
             self.remaining_guesses,
             [self.PLAYER_COLORS[self.guess_to_player.get(guess, 0)] for guess in self.remaining_guesses])
 
-# LetterSource class moved to src/rendering/animations.py
-
-# SoundManager class moved to src/systems/sound_manager.py
 
 class Game:
     def __init__(self, 
@@ -748,9 +745,7 @@ class Game:
 
             if self.letter.locked_on or self.last_lock:
                 self.last_lock = self.letter.locked_on
-                letter_index = self.letter.letter_index() if self.letter.locked_on else None
-                incidents.append("letter_lock")
-                if await self._app.letter_lock(letter_index, now_ms):
+                if await self._app.letter_lock(self.letter.letter_index(), self.letter.locked_on, now_ms):
                     incidents.append("letter_lock")
 
         for player in range(self._app.player_count):
