diff --git a/pygamegameasync.py b/pygamegameasync.py
index 3315b4f..d0a9870 100755
--- a/pygamegameasync.py
+++ b/pygamegameasync.py
@@ -432,6 +432,8 @@ class LetterSource():
         window.blit(self.surface, self.pos)
 
 class Letter():
+    DROP_TIME_MS = 10000
+    NEXT_COLUMN_MS = 1000
     ANTIALIAS = 1
     ACCELERATION = 1.01
     INITIAL_SPEED = 0.020
@@ -446,7 +448,6 @@ class Letter():
         self.letter_width, self.letter_height = rack_metrics.letter_width, rack_metrics.letter_height
         self.width = rack_metrics.letter_width
         self.height = SCREEN_HEIGHT - (rack_metrics.letter_height + initial_y)
-        self.next_interval_ms = 1
         self.fraction_complete = 0
         self.locked_on = False
         self.start_x = self.rack_metrics.get_rect().x
@@ -456,7 +457,7 @@ class Letter():
         self.bounce_sound.set_volume(0.1)
         self.next_letter_easing = easing_functions.ExponentialEaseOut(start=0, end=1, duration=1)
         self.left_right_easing = easing_functions.ExponentialEaseIn(start=1000, end=10000, duration=1)
-        self.top_bottom_easing = easing_functions.ExponentialEaseIn(start=0, end=10000, duration=1)
+        self.top_bottom_easing = easing_functions.CubicEaseIn(start=0, end=1, duration=1)
         self.draw()
 
     def start(self):
@@ -465,6 +466,8 @@ class Letter():
         self.start_fall_y = 0
         self.column_move_direction = 1
         self.next_column_move_time_ms = pygame.time.get_ticks()
+        self.top_bottom_percent = 0
+        self.total_fall_time_ms = self.DROP_TIME_MS
         self.rect = pygame.Rect(0, 0, 0, 0)
         self.pos = [0, 0]
         self.start_fall_time_ms = pygame.time.get_ticks()
@@ -484,20 +487,29 @@ class Letter():
     def draw(self):
         self.surface = self.font.render(self.letter, LETTER_SOURCE_COLOR)[0]
         remaining_ms = max(0, self.next_column_move_time_ms - pygame.time.get_ticks())
-        self.fraction_complete = 1.0 - remaining_ms/self.next_interval_ms
+        self.fraction_complete = 1.0 - remaining_ms/self.NEXT_COLUMN_MS
         self.easing_complete = self.next_letter_easing(self.fraction_complete)
         boost_x = 0 if self.locked_on else self.column_move_direction*(self.width*self.easing_complete - self.width)
+        # print(f"{self.easing_complete} {remaining_ms} {self.fraction_complete} {self.locked_on} {self.get_screen_bottom_y() + Letter.Y_INCREMENT*2} > {self.height}")
         self.pos[0] = self.rack_metrics.get_rect().x + self.rack_metrics.get_letter_rect(self.letter_ix, self.letter).x + boost_x
+        if self.easing_complete >= 1:
+            self.locked_on = self.get_screen_bottom_y() + Letter.Y_INCREMENT*2 > self.height
+            # print(f"{self.easing_complete} {remaining_ms} {self.fraction_complete} {self.locked_on} {self.get_screen_bottom_y() + Letter.Y_INCREMENT*2} > {self.height}")
 
     def update(self, window, score):
         now_ms = pygame.time.get_ticks()
-        time_since_last_fall_s = (now_ms - self.start_fall_time_ms)/1000.0
-        dy = 0 if score < FREE_SCORE else Letter.INITIAL_SPEED * math.pow(Letter.ACCELERATION,
-            time_since_last_fall_s*TICKS_PER_SECOND)
-        self.pos[1] += dy
+        fall_percent = (now_ms - self.start_fall_time_ms)/self.total_fall_time_ms
+        if self.locked_on:
+            print(f"fall percent {fall_percent}")
+        fall_easing = self.top_bottom_easing(fall_percent)
+        self.pos[1] = self.start_fall_y + fall_easing * self.height
         distance_from_top = self.pos[1] / SCREEN_HEIGHT
         distance_from_bottom = 1 - distance_from_top
-        if now_ms > self.last_beep_time_ms + (distance_from_bottom*distance_from_bottom)*7000:
+        remaining = (self.height - self.pos[1])/self.height
+        # print(f"distance:  {remaining} {distance_from_top}")
+        if self.locked_on and now_ms > self.last_beep_time_ms:
+            beep_percent = 10*(fall_easing - 0.75)
+            print(f"{fall_easing} {beep_percent}")
             pygame.mixer.Sound.play(letter_beeps[int(10*distance_from_top)])
             self.last_beep_time_ms = now_ms
 
@@ -506,17 +518,15 @@ class Letter():
         blit_pos = self.pos.copy()
         blit_pos[1] += self.new_game_y
         window.blit(self.surface, blit_pos)
-        self.locked_on = self.get_screen_bottom_y() + Letter.Y_INCREMENT > self.height
-        if now_ms > self.next_column_move_time_ms and not self.locked_on:
-            self.letter_ix = self.letter_ix + self.column_move_direction
-            if self.letter_ix < 0 or self.letter_ix >= tiles.MAX_LETTERS:
-                self.column_move_direction *= -1
-                self.letter_ix = self.letter_ix + self.column_move_direction*2
-
-            percent_complete_y = (self.pos[1] + self.rect.height) / self.height
-            self.next_interval_ms = self.left_right_easing(percent_complete_y)
-            self.next_column_move_time_ms = now_ms + self.next_interval_ms
-            pygame.mixer.Sound.play(self.bounce_sound)
+        if now_ms > self.next_column_move_time_ms:
+            if not self.locked_on:
+                self.letter_ix = self.letter_ix + self.column_move_direction
+                if self.letter_ix < 0 or self.letter_ix >= tiles.MAX_LETTERS:
+                    self.column_move_direction *= -1
+                    self.letter_ix = self.letter_ix + self.column_move_direction*2
+
+                self.next_column_move_time_ms = now_ms + self.NEXT_COLUMN_MS
+                pygame.mixer.Sound.play(self.bounce_sound)
 
     def shield_collision(self):
         # logger.debug(f"---------- {self.start_fall_y}, {self.pos[1]}, {new_pos}, {self.pos[1] - new_pos}")
@@ -529,6 +539,8 @@ class Letter():
 
     def new_fall(self):
         self.start_fall_y += Letter.Y_INCREMENT
+        self.total_fall_time = self.DROP_TIME_MS * (self.height - self.start_fall_y) / self.height
+        print(f"total fall time: {self.total_fall_time}")
         self.pos[1] = self.start_fall_y
         self.start_fall_time_ms = pygame.time.get_ticks()
 
