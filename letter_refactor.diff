diff --git a/src/game/letter.py b/src/game/letter.py
index 1af83ef73..08c1fee6d 100644
--- a/src/game/letter.py
+++ b/src/game/letter.py
@@ -58,6 +58,15 @@ class Letter:
         self.start(0)
         self.draw(0)
 
+    def _recalculate_fall_duration(self) -> None:
+        """Recalculate fall duration based on the current height from start_fall_y to bottom."""
+        # Ensure duration is never negative
+        remaining_height = max(0, self.height - self.start_fall_y)
+        if self.height > 0:
+            self.fall_duration_ms = self.DROP_TIME_MS * remaining_height / self.height
+        else:
+            self.fall_duration_ms = 0
+
     def start(self, now_ms: int) -> None:
         """Initialize letter state for a new game."""
         self.letter = ""
@@ -66,10 +75,12 @@ class Letter:
         self.current_fall_start_y = 0
         self.column_move_direction = 1
         self.next_column_move_time_ms = now_ms + self.NEXT_COLUMN_MS
-        self.fall_duration_ms = self.DROP_TIME_MS
+        
+        self.start_fall_time_ms = now_ms
+        self._recalculate_fall_duration()
+        
         self.rect = pygame.Rect(0, 0, 0, 0)
         self.pos = [0, 0]
-        self.start_fall_time_ms = now_ms
         self.last_beep_time_ms = now_ms
 
         # Reset the descent strategy for new game
@@ -169,25 +180,38 @@ class Letter:
         """Update and render the letter, returning incidents."""
         incidents = []
 
-        # Update red line position from strategy
-        new_y, should_trigger_fall = self.descent_strategy.update(self.start_fall_y, now_ms, self.height)
-        self.start_fall_y = new_y  # Update red line position without resetting fall
-
-        # Red line is above bottom - continue falling
+    def _update_and_get_fall_percent(self, should_trigger_fall: bool, now_ms: int) -> float:
+        """Update internal state related to falling duration and return current fall completion (0.0 to 1.0)."""
         if should_trigger_fall:
-            # Recalculate fall duration based on new starting position
-            remaining_height = self.height - self.start_fall_y  # Guaranteed > 0 in this branch
-            self.fall_duration_ms = self.DROP_TIME_MS * remaining_height / self.height
+            self._recalculate_fall_duration()
 
         # Safeguard against edge cases where fall_duration_ms could be very small
         if self.fall_duration_ms > 0:
             fall_percent = (now_ms - self.start_fall_time_ms) / self.fall_duration_ms
         else:
             fall_percent = 1.0
+            
+        return fall_percent
 
+    def _compute_y_from_state(self, fall_percent: float) -> int:
+        """Compute Y position based on current fall percent and easing."""
         fall_easing = self.top_bottom_easing(fall_percent)
         # Ensure letter never appears above the red line
-        self.pos[1] = max(self.start_fall_y, int(self.current_fall_start_y + fall_easing * self.height))
+        return max(self.start_fall_y, int(self.current_fall_start_y + fall_easing * self.height))
+
+    def update(self, window: pygame.Surface, now_ms: int) -> None:
+        """Update and render the letter, returning incidents."""
+        incidents = []
+
+        # 1. Update the Floor (Strategy)
+        new_y, should_trigger_fall = self.descent_strategy.update(self.start_fall_y, now_ms, self.height)
+        self.start_fall_y = new_y  # Update red line position without resetting fall
+
+        # 2. Update Fall Physics State
+        fall_percent = self._update_and_get_fall_percent(should_trigger_fall, now_ms)
+        
+        # 3. Calculate Position
+        self.pos[1] = self._compute_y_from_state(fall_percent)
 
         self._update_beeping(now_ms)
         self.draw(now_ms)
@@ -220,10 +244,7 @@ class Letter:
             now_ms: Current timestamp
         """
         self.start_fall_y = new_y
-
-        # Ensure duration is never negative
-        remaining_height = max(0, self.height - self.start_fall_y)
-        self.fall_duration_ms = self.DROP_TIME_MS * remaining_height / self.height
+        self._recalculate_fall_duration()
 
         self.pos[1] = self.current_fall_start_y = self.start_fall_y
         self.start_fall_time_ms = now_ms
